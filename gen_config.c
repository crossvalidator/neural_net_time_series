//#include "ancfis.h"
/*
This file deals with generating the connections between the nodes.
This is done by generating a binary matrix where a 1 means there is
a connection and a 0 means no connection.  This matrix is then used
to fill in the "fan_in" and "fan_out" nodes.

There are 5 functions:
1. gen_config
	2. connected
		3. digit_rep
	4. which_layer
		5. between
*/

int VAR_N, MF_N, NODE_N, RULE_N, OUT_N;

/***********************************************
Description:
This function fills in the matrix **config.
**config is then used to define the connections between
the ANFIS nodes in build_anfis(config) in datastru.c

Inputs:
input_no - number of input values
mf_no - number of membership functions for each input
**config - a square matrix generated by gen_config in gen_config.c.
	It is a matrix of dimensions (total number of nodes)x(total number of nodes).
	It contains only 0's and 1's which indicate if there is a forward connection
	between the nodes.

Outputs:
A filled in **config

Called from:
mexFunction in ancfismex.c
************************************************/
void gen_config(int input_no, int mf_no,int Out_n,int **config) {
	printf("crack testing \n");
	int i, j;
	int connected();

	VAR_N = input_no;
	MF_N = mf_no;
	OUT_N=Out_n;
	RULE_N = (int)(pow((double)MF_N, (double)VAR_N));
	NODE_N = VAR_N + VAR_N*MF_N + 3*RULE_N + VAR_N*RULE_N + OUT_N;

	for(i = 0; i < NODE_N; i++) {
		for(j = 0; j < NODE_N; j++)
			config[i][j] = connected(i, j);
	}
}

/***********************************************
Description:
Boolean function which tells if a connection exists
between two nodes i and j.

Inputs:
i - node index
j - node index

Outputs:
1 - connection exists between i and j
0 - connection does not exist between i and j

Called from:
gen_config in gen_config.c
************************************************/
int connected(int i, int j) {
	int which_layer();
	int between();
	void digit_rep();
	int layer1, layer2;
	int group;
	int position;
	int *rep;
	int k;

	if(i >= j)
		return(0);
	layer1 = which_layer(i); //get the layer of node i
	layer2 = which_layer(j); //get the layer of node j
	if((layer2 - layer1 != 1) && layer1 != 0) //if they are not adjacent layers set to 0, except for the input layer
		return(0);
	switch(layer1) {
		case 0:
			if(between(VAR_N + i*MF_N, j, VAR_N + (i+1)*MF_N - 1))
				return(1);
			if(between(VAR_N + VAR_N*MF_N + 3*RULE_N, j, VAR_N + VAR_N*MF_N + 3*RULE_N+ VAR_N*RULE_N- 1))
				return(1);
			break;
		case 1:
			/*
			group = (int)floor((double)((i - VAR_N)/MF_N));
			*/
			rep = calloc(VAR_N, sizeof(int));
			group = (i - VAR_N)/MF_N;
			position = (i - VAR_N) % MF_N;
			digit_rep(rep, j - VAR_N - VAR_N*MF_N);
			if(rep[group] == position)
				return(1);
			break;
		case 2:
			if(between(VAR_N + VAR_N*MF_N + RULE_N, j, VAR_N + VAR_N*MF_N + 2*RULE_N- 1))
				return(1);
			break;
		case 3:
			if(between(VAR_N + VAR_N*MF_N + 2*RULE_N, j, VAR_N + VAR_N*MF_N + 3*RULE_N- 1))
				return(1);
			break;
		case 4:
			for (k=0; k< RULE_N ;k++)
			{
				if(between(VAR_N + VAR_N*MF_N + 3*RULE_N +OUT_N* k , j, VAR_N + VAR_N*MF_N + 3*RULE_N + OUT_N*(k+1) - 1))
				{
					position = k;
					break;
				}
			}
			group = (i - (VAR_N + VAR_N*MF_N + 2*RULE_N))% RULE_N;
			if (position==group)
				return(1);
			break;
		case 5:
			
			position = (i - (VAR_N + VAR_N*MF_N + 3*RULE_N)) % OUT_N;
			group = (j - (VAR_N + VAR_N*MF_N + 3*RULE_N + OUT_N*RULE_N))% OUT_N;
			if (position==group)
				return(1);
			break;
		
		case 6:
			return(0);
			break;
		default:
			printf("Error in layer!\n");
	}
	return(0);
}

/***********************************************
Description:
Inputs:
*rep -
j -

Outputs:
Called from:
connected in gen_config.c
************************************************/
void digit_rep(int *rep, int j) {
	int i;
	for(i = 0; i < VAR_N; i++) {
		rep[VAR_N - i - 1] = j % MF_N;
		/* j = (int)floor((double)(j/MF_N)); */
		j = j/MF_N;
	}
}

/***********************************************
Description:
Returns the layer that a particular node belongs to.

Inputs:
i - the node index

Outputs:
The layer (0 to 6)

Called from:
connected in gen_config.c
************************************************/
int which_layer(int i) {
	int between();

	if(between(0, i, VAR_N - 1))
		return(0);
	if(between(VAR_N, i, VAR_N + VAR_N*MF_N - 1))
		return(1);
	if(between(VAR_N + VAR_N*MF_N, i, VAR_N + VAR_N*MF_N + RULE_N- 1))
		return(2);
	if(between(VAR_N + VAR_N*MF_N + RULE_N, i, VAR_N + VAR_N*MF_N + 2*RULE_N- 1))
		return(3);
	if(between(VAR_N + VAR_N*MF_N + 2*RULE_N, i, VAR_N + VAR_N*MF_N + 3*RULE_N- 1))
		return(4);
	if(between(VAR_N + VAR_N*MF_N + 3*RULE_N, i, VAR_N + VAR_N*MF_N + 3*RULE_N+ VAR_N*RULE_N- 1))
		return(5);
	if(i = VAR_N + VAR_N*MF_N + 4*RULE_N)
		return(6);

	printf("Error in which_layer!\n");
	return(0); //suppress compiler warning
}

/***********************************************
Description:
Boolean function which determines if l<=x<=u

Inputs:
l - lower limit
x - value to be tested
u - upper limit

Outputs:
1 - if l<=x<=u
0 - otherwise

Called from:
which_layer, connected in gen_config.c
************************************************/
int between(int l, int x, int u) {
	if((l <= x) && (x <= u))
		return(1);
	else
		return(0);
}

